
apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: agentic-sandbox
spec:
  # `schema` section of the spec defines the CRD that will be created by KRO for users to consume.
  # This follows a simplified specification: https://kro.run/docs/concepts/simple-schema/
  schema:
    # The user facing CRD that KRO will create
    apiVersion: v1alpha1
    group: custom.agents.x-k8s.io
    kind: AgenticSandbox
    # Spec fields that users can provide.
    types:
      egressRule: object
    spec:
      image: string | default="nginx"
      service:
        port: integer | default=80
      networkPolicy:
        enabled: boolean | default=false
        ingress:
          podLabels: "map[string]string"
          namespaceLabels: "map[string]string"
        egress: "[]egressRule"
      ingress:
        enabled: boolean | default=false
    status:
      # Fields the controller will inject into instances status.
      fqdn: ${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local
      sandboxConditions: ${sandbox.status.conditions}
  # `resources` section defines the resources that will be created when a user creates an `AgenticSandbox` resource.
  # This follows a simplified specification: https://kro.run/docs/concepts/resource-graph
  # Each resource has an `id` that can be referenced by other resources, a `template` that defines the resource to create,
  # and optional `readyWhen` and `includeWhen` fields to control resource creation and readiness.
  # We can use CEL expressions to reference fields from the `schema` and other resources.
  # See https://kro.run/docs/concepts/cel-expressions/ for more details
  graph:
  resources:
    - id: sandbox
      readyWhen: # CEL expressions to determine when a resource is ready
      - ${sandbox.status.conditions.exists(x, x.type == 'Ready' && x.status == "True")}
      template:
        apiVersion: agents.x-k8s.io/v1alpha1
        kind: Sandbox
        metadata:
          # CEL expressions to reference fields from the `schema`
          name: ${schema.metadata.name} # Use the name provided by user
        spec:
          podTemplate:
            metadata:
              labels:
                sandbox: ${schema.metadata.name}
            spec:
              containers:
                - name: sandbox
                  image: ${schema.spec.image}
                  ports:
                    # CEL expressions to reference fields from the `schema`
                    - containerPort: ${schema.spec.service.port}
    - id: service
      template:
        apiVersion: v1
        kind: Service
        metadata:
          name: ${schema.metadata.name}-lb
        spec:
          selector:
            sandbox: ${schema.metadata.name}
          ports:
            - protocol: TCP
              port: ${schema.spec.service.port}
              targetPort: ${schema.spec.service.port}
    - id: nwpolicy
      includeWhen:
        - ${schema.spec.networkPolicy.enabled}
      template:
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        metadata:
          name: allow-frontend-to-backend
          namespace: default
        spec:
          podSelector:
            matchLabels:
              sandbox: ${schema.metadata.name}
          policyTypes:
            - Ingress
            - Egress
          ingress:
          - from:
            - podSelector:
                matchLabels: ${schema.spec.networkPolicy.ingress.podLabels}
            - namespaceSelector:
                matchLabels: ${schema.spec.networkPolicy.ingress.namespaceLabels}
          egress: ${schema.spec.networkPolicy.egress}
    - id: ingress
      includeWhen:
        - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress
      template:
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: ${schema.metadata.name}
        spec:
          defaultBackend:
            service:
              # CEL expressions to reference fields from the resource `service`
              # this causes ingress to be created only after service is created
              name: ${service.metadata.name}
              port:
                number: ${schema.spec.service.port}
