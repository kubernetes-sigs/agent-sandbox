#!/usr/bin/env python3
# Copyright 2025 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import io
import os
import subprocess
import yaml

from shared import utils


def find_and_replace_images(doc, image_prefix, image_tag):
    """Recursively finds and replaces container images in a Kubernetes manifest.

    This function specifically targets image fields that either use the 'ko://'
    prefix or have a ':latest' tag, replacing them with a fully qualified
    and versioned image name.

    Args:
        doc (dict): The Kubernetes manifest document to process.
        image_prefix (str): The image registry prefix (e.g., 'us-docker.pkg.dev/my-project/').
        image_tag (str): The image tag to apply (e.g., 'v1.2.3').
    """
    def fn(field_path, v):
        if field_path == ".spec.template.spec.containers[].image":
            # We only replace images that look like :latest
            image_and_tag = v.split(":")
            if len(image_and_tag) == 2 and image_and_tag[1] == "latest":
                v2 = f"{image_prefix}{image_and_tag[0]}:{image_tag}"
                print(f"{v}: replaced image with {v2}")
                v = v2
            if v.startswith("ko://"):
                # ko://foo/bar/command-name -> image_prefix + command-name + image_tag
                command_name = v.split("/")[-1]
                v2 = f"{image_prefix}{command_name}:{image_tag}"
                print(f"{v}: replaced image with {v2}")
                v = v2
        return v
    walk_object(doc, fn)


def walk_object(obj, fn, field_path=""):
    """Recursively walks through a nested dictionary or list and applies a function.

    Args:
        obj (dict | list): The object to walk through.
        fn (function): A function to apply to each field. It receives the
            field path (e.g., '.spec.template.spec') and the value.
        field_path (str, optional): The current path in the object. Used for
            recursive calls. Defaults to "".
    """
    if isinstance(obj, dict):
        for k, v in obj.items():
            v2 = fn(f"{field_path}.{k}", v)
            obj[k] = v2
            walk_object(v, fn, field_path=f"{field_path}.{k}")
    elif isinstance(obj, list):
        for item in obj:
            walk_object(item, fn, field_path=field_path + "[]")
    elif isinstance(obj, str) or isinstance(obj, int) or isinstance(obj, float) or obj is None:
        pass
    else:
        raise Exception(f"unexpected type: {type(obj)}")


def kubectl_apply_objects(docs, repo_root):
    """Applies a list of Kubernetes documents using 'kubectl apply'.

    Args:
        docs (list): A list of Kubernetes manifest documents.
        repo_root (str): The path to the repository root, used as the working
            directory for the subprocess call.
    """
    if not docs: return
    string_stream = io.StringIO()
    yaml.dump_all(docs, string_stream)
    subprocess.run(["kubectl", "apply", "-f", "-"], cwd=repo_root, check=True, input=string_stream.getvalue(), text=True)


def gather_manifests(manifests_path):
    """Scans a directory for YAML files and parses them into a structured list.

    This function walks through the given directory, reads all '.yaml' or '.yml'
    files, and handles multi-Kubernetes object files by splitting them into individual
    objects.

    Args:
        manifests_path (str): The path to the directory containing manifests.

    Returns:
        list: A flat list of dictionaries. Each dictionary represents a single
              Kubernetes object and contains the document itself ('doc'), its
              original 'filename', its 'kind', and the 'root' directory it was found in.
    """
    all_docs = []
    if not os.path.isdir(manifests_path):
        print("k8s directory not found")
        return all_docs

    for root, _, files in os.walk(manifests_path):
        for filename in files:
            if not (filename.endswith(".yaml") or filename.endswith(".yml")):
                continue
            path = os.path.join(root, filename)
            with open(path, "r") as f:
                docs = list(yaml.safe_load_all(f))
                for doc in docs:
                    if doc:
                        all_docs.append({
                            "doc": doc,
                            "filename": filename,
                            "kind": doc.get("kind"),
                        })
    return all_docs


def process_manifests(all_docs, args):
    """Filters, modifies, and sorts a list of raw manifest objects.

    This function applies the core deployment logic based on the script's
    arguments. It filters out unwanted documents, replaces image tags, and
    sorts the documents into three batches for ordered application:
    prerequisites, standard documents, and extensions documents.

    Args:
        all_docs (list): The raw list of manifest objects from gather_manifests.
        args (argparse.Namespace): The parsed command-line arguments.

    Returns:
        tuple: A tuple containing three lists of documents:
               (prereq_docs, other_docs, extensions_docs).
    """
    prereq_docs = []
    extensions_docs = []
    other_docs = []

    image_prefix = utils.get_image_prefix(args)
    image_tag = utils.get_image_tag()

    for item in all_docs:
        doc = item["doc"]
        filename = item["filename"]
        kind = item["kind"]

        is_extension_file = filename.startswith("extensions")
        if is_extension_file and not args.extensions:
            continue

        # When extensions is enabled, we skip the core controller manifest because
        # it will be replaced by the one in the extensions directory.
        is_core_controller = (
            doc.get("metadata", {}).get("name") == "agent-sandbox-controller" and
            kind in ["StatefulSet", "Deployment"] and
            not is_extension_file
        )
        if args.extensions and is_core_controller:
            continue

        find_and_replace_images(doc, image_prefix, image_tag)

        if kind in ["CustomResourceDefinition", "Namespace"]:
            prereq_docs.append(doc)
        elif is_extension_file:
            extensions_docs.append(doc)
        else:
            other_docs.append(doc)

    return prereq_docs, other_docs, extensions_docs


def apply_manifests(prereq_docs, other_docs, extensions_docs, repo_root, apply_extensions):
    """Applies the processed manifests to the cluster in the correct order.

    The order of application is:
    1. Prerequisites (Namespaces, CRDs)
    2. Standard resources
    3. Extension resources (if enabled)

    Args:
        prereq_docs (list): A list of prerequisite manifest documents.
        other_docs (list): A list of standard manifest documents.
        extension_docs (list): A list of extension manifest documents.
        repo_root (str): The path to the repository root.
        apply_extensions (bool): Whether to apply the extension manifests.
    """
    print(f"Applying {len(prereq_docs)} prerequisite manifests (Namespace, CRDs)...")
    kubectl_apply_objects(prereq_docs, repo_root)

    print(f"Applying {len(other_docs)} other manifests...")
    kubectl_apply_objects(other_docs, repo_root)

    if apply_extensions:
        print(f"Applying {len(extensions_docs)} extensions manifests...")
        kubectl_apply_objects(extensions_docs, repo_root)

    print("Deployment complete.")


def main(args):
    """Orchestrates the Kubernetes deployment process.

    This function calls the gather, process, and apply functions in sequence
    to carry out the full deployment workflow.

    Args:
        args (argparse.Namespace): The parsed command-line arguments.
    """
    repo_root = utils.get_repo_root()
    manifests_path = os.path.join(repo_root, "k8s")

    all_docs = gather_manifests(manifests_path)
    prereq_docs, other_docs, extension_docs = process_manifests(all_docs, args)
    apply_manifests(prereq_docs, other_docs, extension_docs, repo_root, args.extensions)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Deploy manifests under k8s/ to Kubernetes cluster")
    parser.add_argument("--image-prefix",
                        dest="image_prefix",
                        help="prefix for the image name. requires slash at the end if a path",
                        type=str,
                        default=os.getenv("IMAGE_PREFIX"))
    parser.add_argument("--extensions",
                        action="store_true",
                        help="Apply the extensions controller manifest.")
    args = parser.parse_args()
    main(args)
